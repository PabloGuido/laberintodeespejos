local datos = require("main.datos")
local niveles = require("gui.niveles")
local dif_entre_casillas = 142

local function finalizar_botones(self)
	if datos.nivel_completado == false then
		gui.animate(self.retroceder, "position.y", 835, gui.EASING_INBACK, 1)
		gui.animate(self.sonido_nodo, "position.x", 1354, gui.EASING_INBACK, 1)
		if self.pistas_activadas == false then
			gui.animate(self.lupa, "position.x", 1391, gui.EASING_INBACK, 1)
		end
	else
		gui.set_enabled(self.retroceder, false)
		gui.set_enabled(self.sonido_nodo, false)
		if self.pistas_activadas == false then
			gui.animate(self.lupa, "position.x", 1391, gui.EASING_INBACK, 1, 0,
			function()
				gui.set_enabled(self.lupa, false)
			end)
		end
	end
end

local function terminar_escena_gameplay(self)
	if datos.jugar_nivel < 10 then
		datos.jugar_nivel = datos.jugar_nivel + 1
	
		if datos.ultimo_nivel_desbloqueado == datos.jugar_nivel - 1 then
			datos.ultimo_nivel_desbloqueado = datos.ultimo_nivel_desbloqueado + 1
		end
	end
	
	for c = 1, table.maxn(self.casillas) do
		local anim_casilla = self.casillas[c][1][hash("casilla")]
		gui.animate(anim_casilla, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end
	for o = 1 ,table.maxn(self.obstaculos_tabla) do
		local anim_obs = self.obstaculos_tabla[o][hash("obstaculo")]
		gui.animate(anim_obs, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end
	for s = 1 ,table.maxn(self.switches) do
		gui.animate(self.switches[s], "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end
	for l = 1,table.maxn(self.laser_tabla) do
		gui.animate(self.laser_tabla[l][hash("laser_beam")], "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end
	for e = 1 ,table.maxn(self.espejos) do		
		gui.animate(self.espejos[e][hash("espejo")], "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
		if self.espejos[e]["laser"] ~= nil then
			gui.animate(self.espejos[e]["laser"], "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
		end
		gui.animate(self.laser_relevo, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end
	for p = 1,table.maxn(self.pistas) do
		gui.animate(self.pistas[p][hash("pista")], "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end
	gui.animate(self.laser_beam, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	gui.animate(self.objetivo, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	gui.animate(self.fondo_gris, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	gui.animate(self.cannon, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	if gui.is_enabled(self.adorno) then
		gui.animate(self.adorno, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end
	if gui.is_enabled(self.barrera) then
		gui.animate(self.barrera, "color", vmath.vector4(1,1,1,0), gui.EASING_LINEAR, 1)
	end

	finalizar_botones(self)
	msg.post("/delta#delta", "finalizar_escena")
	gui.animate(self.espejo, "position.x", -150, gui.EASING_INBACK, 1)
	gui.animate(self.numero_de_nivel, "position.x", -280, gui.EASING_INBACK, 1)
	gui.animate(self.toolbar, "position.x", -150, gui.EASING_INBACK, 1, 0, function()
		datos.obj_en_mouse = nil
		if self.volver_a_seleccion_de_nivel == true then
			msg.post("loader:/loader#loader", "retroceder_escena")
		else
			print("VAMOS AL SIGUIENTE NIVEL")
			niveles[self.nivel+1]["habilitado"] = true ---
			msg.post("loader:/loader#loader", "siguiente_nivel")
		end
	end)
end

local function inicializacion_objetos_alpha(self) -- Da el input focus inicial.
	for c = 1, table.maxn(self.casillas) do
		local anim_casilla = self.casillas[c][1][hash("casilla")]
		--pprint(self.casillas[c][1][hash("casilla")])
		gui.animate(anim_casilla, "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1)
		--pprint(self.obstaculos_tabla)
	end
	for o = 1 ,table.maxn(self.obstaculos_tabla) do
		local anim_obs = self.obstaculos_tabla[o][hash("obstaculo")]
		gui.animate(anim_obs, "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1)
	end
	for s = 1 ,table.maxn(self.switches) do
		gui.animate(self.switches[s], "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1)
	end
	for l = 1,table.maxn(self.laser_tabla) do
		gui.animate(self.laser_tabla[l][hash("laser_beam")], "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1)
	end
	gui.animate(self.laser_beam, "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1)
	gui.animate(self.barrera, "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1)
	gui.animate(self.cannon, "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1)
	gui.move_below(self.sonido_nodo, self.tacho)
	gui.move_below(self.retroceder, self.tacho)
	gui.move_below(self.lupa, self.tacho)
	-- Acá vamos a poner la inicialización de los tutoriales.
	gui.animate(self.objetivo, "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 1, 0)
end

local function on_off_sonido(self, sonido)
	if datos.sound == true then
		sound.play(sonido)
	else
		sound.stop(sonido)
	end
end

local function mover_bajo_adorno(self, nodo)
	gui.move_below(nodo, self.adorno)
end

local function clonar_nodo(self, que_nodo, que_hash, pos, que_tabla, en_mouse)
	local nuevo_nodo = gui.clone_tree(que_nodo)
	local clon_nodo = nuevo_nodo[que_hash]
	gui.set_position(clon_nodo, pos)
	table.insert(que_tabla, nuevo_nodo)
	local obj_en_mouse = en_mouse
	if obj_en_mouse == true then
		datos.obj_en_mouse = clon_nodo
	end
	return clon_nodo
end

local function mensaje_para_ui (self)
	local pos_obj = gui.get_position(self.ultimo_obj_clickeado)
	local obj = self.ultimo_obj_clickeado
	--print("enviando mensaje al ui")
	msg.post("/ui_objetos#ui_objetos", "activar_ui_objetos", {pos = pos_obj, obj = tostring(obj)})
end


local function mover_relevo(self, posicion)
	msg.post("/espejo_relevo#espejo_relevo", "mover_relevo", {pos = posicion})
	gui.set_position(self.laser_relevo, posicion)
	--print(gui.get_position(self.laser_relevo, posicion))
	--print(posicion)
end

local function mover_abajo_botones(self, nodo)
	gui.move_below(self.sonido_nodo, nodo)
	gui.move_below(self.retroceder, nodo)
	gui.move_below(self.lupa, nodo)
end

local function mover_tacho(self, posicion, nodo)
	local pos = posicion
	pos.y = pos.y - 115
	gui.set_position(self.tacho, pos)
	--gui.move_above(self.tacho, nodo)
	if nodo ~=nil then --???????
		local rot = gui.get_rotation(nodo)
	--	print(rot.z/90)
	end
end
-- switches ---------------------

local function desactivar_activar_barrera(self)
	if self.cantidad_de_switches_activados == self.cantidad_de_switches_en_el_nivel then
		msg.post("/barrera#barrera", "desactivar_barrera")
		gui.set_enabled(self.barrera, false)
		--[[ -- Animación que no estaría funciondo con el sistema. No creo que vaya a hacer el corte.
		if gui.is_enabled(self.barrera) then
			local escala_barrera = gui.get_scale(self.barrera)
			gui.animate(self.barrera, "scale", escala_barrera*1.25, gui.EASING_INBOUNCE, 0.75, 0,
			function()
				gui.set_scale(self.barrera, escala_barrera)
				if self.cantidad_de_switches_activados == self.cantidad_de_switches_en_el_nivel then
					gui.set_enabled(self.barrera, false)
				end
				--msg.post("/barrera#barrera", "desactivar_barrera")
			end)
		end
		]]
	else
		gui.set_enabled(self.barrera, true)
		msg.post("/barrera#barrera", "activar_barrera")
	end
	
end

-- laser beam -------------------
local function dist2d(x1, y1, x2, y2)
	return ((x2-x1)^2+(y2-y1)^2)^0.5
end

local function angle_of_vector_between_two_points(x1,y1, x2,y2) 
	return math.atan2(y2-y1, x2-x1) 
end

---------------------------------

function init(self)
	--msg.post("@render:", "clear_color", { color = vmath.vector4(0.15, 0.25, 0.15, 0) } )
	-- Valores para inicios ---------------------------
	datos.primera_vez_que_abre_gameplay = false


	gui.set_render_order(2)
	-- niveles ----------------------------------------
	self.nivel = datos.jugar_nivel
	niveles[self.nivel]["habilitado"] = true
	
	self.contador_para_leer_mapa_nivel = 1
	self.cantidad_de_switches_en_el_nivel = niveles[self.nivel]["switches"]
	self.cantidad_de_switches_activados = 0

	datos.nivel_completado = false -- esto no va después creo. ?
	---------------------------------------------------
	self.moviendo_obj = false
	self.ultima_pos = vmath.vector3()
	self.delta_pos = vmath.vector3()
	self.casilla_delta = ""
	self.casilla_delta2 = ""
	
	self.ultima_casilla = 1
	self.pos_casilla = vmath.vector3()
	self.mouse_sobre_casillas = false -- Registra si el mouse está sobre un casillero.
	self.ultimo_obj_clickeado = nil
	-- nodos -----------------------------------------
	self.casilla = gui.get_node("casilla") -- casilla vacía
	self.cruz = gui.get_node("cruz")
	gui.set_enabled(self.cruz, false)
	self.objetivo = gui.get_node("objetivo")
	self.obstaculo = gui.get_node("obstaculo")
	self.barrera = gui.get_node("barrera")	
	gui.animate(self.barrera, "rotation.z", -180, gui.EASING_LINEAR, 50, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	gui.set_color(self.barrera , vmath.vector4(1,1,1,0))
	self.laser_en_barrera = false
	self.switch = gui.get_node("switch")
	self.adorno = gui.get_node("adorno")
	gui.animate(self.adorno, "rotation.z", 360, gui.EASING_LINEAR, 25, 0, nil, gui.PLAYBACK_LOOP_FORWARD)
	gui.set_enabled(self.adorno, false)
	self.sonido_nodo = gui.get_node("sonido")
	if datos.sonido == false then
		gui.play_flipbook(self.sonido_nodo, "sonido off")
	end
	self.lupa = gui.get_node("lupa")
	self.pista = gui.get_node("pista")
	self.pistas_activadas = false
	self.fondo_gris = gui.get_node("fondo_gris")
	self.numero_de_nivel = gui.get_node("numero_de_nivel") 
	self.numero_de_nivel_t = gui.get_node("numero_de_nivel_t") 
	gui.set_text(self.numero_de_nivel_t, "Nivel " .. datos.jugar_nivel)
	-- tacho ----------------------------------------------
	self.tacho = gui.get_node("tacho")
	self.tacho_pos_inical = vmath.vector3(-600, 300, 0)
	gui.animate(self.tacho, "rotation.z", -5, go.EASING_LINEAR, 1, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)

	-- laser beam -----------------------------------------
	self.laser_beam = gui.get_node("laser_beam")
	gui.set_color(self.laser_beam , vmath.vector4(1,1,1,0))
	self.laser_relevo = gui.get_node("laser_relevo")
	gui.is_enabled(self.laser_beam, false)
	self.position = gui.get_position(self.laser_beam )
	self.target_position = gui.get_position(self.laser_beam )
	self.scale = gui.get_scale(self.laser_beam )
	self.play_stop = gui.get_node("play_stop")
	gui.set_enabled(self.play_stop, false)
	self.laser_prendido = false
	self.cannon = gui.get_node("cannon")
	gui.set_color(self.cannon , vmath.vector4(1,1,1,0))
	gui.set_rotation(self.cannon, niveles[self.nivel]["rotacion"])
	--print(gui.get_rotation(self.cannon))
	self.cannon_adorno = gui.get_node("cannon_adorno")
	-- clonacion de beams
	self.laser_tabla = {}
	

	-- obj toolbar
	self.toolbar = gui.get_node("toolbar")
	self.espejo = gui.get_node("espejo")
	self.espejo_doble = gui.get_node("espejo_doble")
	gui.set_enabled(self.espejo_doble, false)
	self.ui_objetos = false
	self.retroceder = gui.get_node("retroceder")
	-- tablas -----------------------------------------
	self.casillas = {}
	self.casillas["obj_fisico"] = nil
	self.espejos = {}
	self.switches = {}
	self.switches_activados = {}
	self.obstaculos_tabla = {}
	self.pistas = {}
	---------------------------------------------------
	
	self.obj_seleccionado = ""
	self.volver_a_seleccion_de_nivel = false
	self.ultimo_pressed = false

	---------------------------------------------------
	self.pos_x_casillas = 400
	self.pos = vmath.vector3(self.pos_x_casillas,660,0) -- posicion inicial para crear la grilla
	for i = 1, niveles[self.nivel]["cuanto_por_cuanto"] do
		for i = 1, niveles[self.nivel]["cuanto_por_cuanto"] do
			--print(niveles[tostring(self.nivel)][self.contador_para_leer_mapa_nivel])
			local constatador = niveles[tostring(self.nivel)][self.contador_para_leer_mapa_nivel]
			local ocupado = false
			local nuevo_switch
			--print(niveles["1"][self.contador_para_leer_mapa_nivel])
			if constatador == 2 then -- Coloca el objetivo en lugar
				-- Y esto debería enviar un mensaje para crear un objeto fisico del "objetivo"
				gui.set_position(self.objetivo, self.pos)
				gui.set_position(self.barrera, self.pos)
				gui.set_color(self.objetivo, vmath.vector4(1,1,1,0))
				msg.post("/objetivo", "mover_posicion", {pos = self.pos})
				msg.post("barrera", "mover_posicion", {pos = self.pos})
				ocupado = true
			elseif constatador == 1 then -- Coloca obstáculos
				msg.post("/obstaculo_factory_obj#obstaculo_factory_scr", "crear_obstaculo", {pos = self.pos})
				ocupado = true
				local nuevo_obs = clonar_nodo(self, self.obstaculo, hash("obstaculo"), self.pos, self.obstaculos_tabla, false)
				gui.set_color(nuevo_obs, vmath.vector4(1,1,1,0))
			elseif constatador == 3 then -- Coloca switches
				ocupado = true
				nuevo_switch = clonar_nodo(self, self.switch, hash("switch"), self.pos, {}, false)
				table.insert(self.switches, nuevo_switch)
				gui.set_color(nuevo_switch, vmath.vector4(1,1,1,0))
				--pprint(datos.switches)
				msg.post("/switches#switchfactory", "crear_switch", {pos = self.pos, nodo = tostring(nuevo_switch), pos_en_tabla = self.contador_para_leer_mapa_nivel})
			elseif constatador == 4 then -- Coloca el cannon
				ocupado = true
				gui.set_position(self.cannon, self.pos)
				print(self.pos)
				msg.post("laser#laser", "posicion_inicial", {pos = self.pos})
			elseif constatador == 5 then
				local nueva_pista = clonar_nodo(self, self.pista, hash("pista"), self.pos, self.pistas, false)
				gui.move_above(nueva_pista, self.fondo_gris)
				gui.set_color(nueva_pista, vmath.vector4(1,1,1,0))
			end
			
			local nueva_casilla = gui.clone_tree(self.casilla)
			local clon_casilla = nueva_casilla[hash("casilla")]
			gui.set_position(clon_casilla, self.pos)
			table.insert(self.casillas, {nueva_casilla, ocupado = ocupado})
			mover_bajo_adorno(self, clon_casilla)
			gui.move_above(self.barrera, clon_casilla)
			gui.set_color(clon_casilla, vmath.vector4(1,1,1,0))

			local function segundo_laser_switch(self)
				self.ultima_casilla = self.contador_para_leer_mapa_nivel
				local nuevo_laser_beam = clonar_nodo(self, self.laser_beam, hash("laser_beam"), self.pos, self.laser_tabla, false)
				gui.set_color(nuevo_laser_beam, vmath.vector4(1,1,1,0))
				self.casillas[self.ultima_casilla]["laser2"] = nuevo_laser_beam
				gui.set_scale(nuevo_laser_beam, vmath.vector3(1,1,0))
				gui.move_below(nuevo_laser_beam, nuevo_switch)
				gui.move_above(nuevo_laser_beam, self.fondo_gris)
			end
			
			if constatador == 3 then  -- esto es para poner el laser en los switches
				self.ultima_casilla = self.contador_para_leer_mapa_nivel
				local nuevo_laser_beam = clonar_nodo(self, self.laser_beam, hash("laser_beam"), self.pos, self.laser_tabla, false)
				gui.set_color(nuevo_laser_beam, vmath.vector4(1,1,1,0))
				self.casillas[self.ultima_casilla]["laser"] = nuevo_laser_beam
				gui.set_scale(nuevo_laser_beam, vmath.vector3(1,1,0))
				gui.move_below(nuevo_laser_beam, nuevo_switch)
				gui.move_above(nuevo_laser_beam, self.fondo_gris)
				--print("cuantos laser en switches")
				segundo_laser_switch(self)
			end
			
			self.pos.x = self.pos.x + dif_entre_casillas
			self.contador_para_leer_mapa_nivel = self.contador_para_leer_mapa_nivel + 1

		end
		self.pos.x = self.pos_x_casillas
		self.pos.y = self.pos.y - dif_entre_casillas
	end
	
	self.contador_para_leer_mapa_nivel = 1
	-- Esto estaría deshabilitando sin problemas aparentes los nodos que fueron orignalmente clonados y no son necesarios.
	gui.set_enabled(self.casilla, false) -- ver que esto no haga bardo dsp
	gui.set_enabled(self.pista, false)
	---------------------------------------------------
	-- Inicialización --
	gui.animate(self.fondo_gris, "position.y", 376, gui.EASING_OUTCUBIC, 1, 0,
	function()
		inicializacion_objetos_alpha(self) -- Esta función es la que arrancaría el juego digamos.
	end)
	sound.play("/sonidos#gameplay",{gain = datos.gain_sfx})
	gui.animate(self.retroceder, "position.y", 699, gui.EASING_OUTCUBIC, 1)
	gui.animate(self.sonido_nodo, "position.x", 1218, gui.EASING_OUTCUBIC, 1)
	gui.animate(self.lupa, "position.x", 1173, gui.EASING_OUTCUBIC, 1)
	gui.animate(self.espejo, "position.x", 155, gui.EASING_OUTCUBIC, 1)
	gui.animate(self.numero_de_nivel, "position.x", 152, gui.EASING_OUTCUBIC, 1)
	gui.animate(self.toolbar, "position.x", 155, gui.EASING_OUTCUBIC, 1)
	desactivar_activar_barrera(self)
	--print("Nivel " .. self.nivel .. " superado: ")
	--print(niveles[self.nivel]["superado"] )
	--print("----------")
end


function on_message(self, message_id, message, sender)
	--pprint(message_id)
	if message_id == hash("obj_seleccionado") then
		self.obj_seleccionado = message.objeto
		--(self.obj_seleccionado)
	elseif message_id == hash("dibujar_laser_inicial") then
		--pprint(message)
		gui.set_position(self.laser_beam, message.pos_inicial_laser)
		local distance = dist2d(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
		self.scale.x = distance
		gui.set_scale(self.laser_beam, self.scale)
		local direction = angle_of_vector_between_two_points(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
		local rotation = vmath.quat_rotation_z(direction)
		gui.set_rotation(self.laser_beam, rotation)
	elseif message_id == hash("dibujar_laser_relevo") then
		--pprint(message)
		if message.datos then
			gui.set_position(self.laser_relevo, message.pos_inicial_laser)
			local distance = dist2d(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
			self.scale.x = distance
			gui.set_scale(self.laser_relevo, self.scale)
			local direction = angle_of_vector_between_two_points(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
			local rotation = vmath.quat_rotation_z(direction)
			gui.set_rotation(self.laser_relevo, rotation)
		end
	elseif message_id == hash("desactivar_laser_relevo") then
		gui.set_scale(self.laser_relevo, vmath.vector3(1,1,0))
	elseif message_id == hash("dibujar_laser") then
		if message.datos then
			--pprint(message)
			--print(message.instancia)
			for i = 1, table.maxn(self.casillas) do
				--print(message.instancia)
				if self.casillas[i]["instancia"] == message.instancia then
					--print("misma instancia " ..  message.instancia)
					local distance = dist2d(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
					self.scale.x = distance
					
					gui.animate(self.casillas[i]["laser"], "scale.x", self.scale, gui.EASING_LINEAR, 0, 0,
					function()
						--msg.post("", "acquire_input_focus")
						msg.post(message.datos.id, "disparar_ray")
					end)

					local direction = angle_of_vector_between_two_points(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
					local rotation = vmath.quat_rotation_z(direction)
					gui.set_rotation(self.casillas[i]["laser"], rotation)
					gui.move_below(self.laser_beam, self.espejo)
				end
			end
		end
		-------------------------
	elseif message_id == hash("dibujar_laser2") then
		if message.datos then
			--pprint(message)
			--print(message.instancia)
			for i = 1, table.maxn(self.casillas) do
				--print(message.instancia)
				if self.casillas[i]["instancia"] == message.instancia then
					--print("misma instancia " ..  message.instancia)
					local distance = dist2d(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
					self.scale.x = distance

					gui.animate(self.casillas[i]["laser2"], "scale.x", self.scale, gui.EASING_LINEAR, 0, 0,
					function()
						--msg.post("", "acquire_input_focus")
						msg.post(message.datos.id, "disparar_ray")
					end)

					local direction = angle_of_vector_between_two_points(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
					local rotation = vmath.quat_rotation_z(direction)
					gui.set_rotation(self.casillas[i]["laser2"], rotation)
					gui.move_below(self.laser_beam, self.espejo)
				end
			end
		end

		-------------------------------
	elseif message_id == hash("borrar_laser") then
		--pprint(message)
		for i = 1, table.maxn(self.casillas) do
			if self.casillas[i]["instancia"] == message.instancia then
				if self.casillas[i]["laser"] ~= nil then
					gui.set_scale(self.casillas[i]["laser"], vmath.vector3(1,1,0))
				end
			end
		end
		-------------------------------
	elseif message_id == hash("borrar_laser2") then
		for i = 1, table.maxn(self.casillas) do
			if self.casillas[i]["instancia"] == message.instancia then
				if self.casillas[i]["laser2"] ~= nil then
					gui.set_scale(self.casillas[i]["laser2"], vmath.vector3(1,1,0))
				end
			end
		end
		-------------------------------
	elseif message_id == hash("accion_ui_obj") then
		local function test()
			msg.post("/ui_objetos#ui_objetos", "restablecer_input")
		end
		msg.post("", "release_input_focus")
		self.mouse_sobre_casillas = true
		if message.accion == "derecha" then
			local rot = gui.get_rotation(self.ultimo_obj_clickeado)
			gui.animate(self.ultimo_obj_clickeado, "rotation.z", rot.z - 90, gui.EASING_INBACK, 0.45, 0,
			function()
				msg.post(self.casillas[self.ultima_casilla]["instancia"], "accion_gui", {accion= "rot_der", valor = -1})

				timer.delay(0.1, false, test)
				--msg.post("", "acquire_input_focus")
			end	)
		elseif message.accion == "izquierda" then
			local rot = gui.get_rotation(self.ultimo_obj_clickeado)
			gui.animate(self.ultimo_obj_clickeado, "rotation.z", rot.z + 90, gui.EASING_INBACK, 0.45, 0,
			function()
				msg.post(self.casillas[self.ultima_casilla]["instancia"], "accion_gui", {accion= "rot_izq", valor = 1})

				timer.delay(0.1, false, test)
				--msg.post("", "acquire_input_focus")
			end	)
		elseif message.accion == "aceptar" and datos.nivel_completado == false then
			self.ui_objetos = false
			msg.post("", "acquire_input_focus")
			gui.set_enabled(self.adorno, false)
		elseif message.accion == "borrar_objeto" then
			for i = table.maxn(self.espejos), 1, -1 do
				if self.ultimo_obj_clickeado == self.espejos[i][hash("espejo")] then
					-- borra nodo espejo y laser
					gui.delete_node(self.espejos[i][hash("espejo")])
					gui.delete_node(self.espejos[i]["laser"])
					table.remove(self.espejos, i)
					
					--pprint(self.espejos)
					--print(self.ultimo_obj_clickeado)
					for k, v in pairs(self.casillas) do -- No se que onda esto, si no hace error no lo toco mas.
						-- Este pedazo de código es medio curioso pero parece funcionar por el momento, o al menos mejor que antes.
						-- desocupa la casilla y borra obj físico
						if tostring(self.casillas[k][1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
							self.casillas[k]["ocupado"] = false
							if self.casillas[self.ultima_casilla]["instancia"] == nil then
								msg.post(self.casillas[self.casilla_delta]["instancia"], "borrar_obj")
								self.casillas[self.casilla_delta]["laser"] = nil
							else
								msg.post(self.casillas[self.ultima_casilla]["instancia"], "borrar_obj")
								self.casillas[self.ultima_casilla]["laser"] = nil
							end
							
							self.casillas[self.ultima_casilla]["instancia"] = nil -- esta pos de table es la instancia del objeto físico.
							sound.play("/sonidos#tacho", {gain = datos.gain_sfx})
						end
					end
				end
			end
			self.ui_objetos = false
			--msg.post("", "acquire_input_focus") -- ?
		end
			
	elseif message_id == hash("guardar_obj_fisico") then
		--print(message)
		self.casillas[self.ultima_casilla]["instancia"] =  message.obj
	elseif message_id == hash("guardar_obj_fisico_nodo") then
		--pprint(message)
		self.casillas[message.pos_en_tabla]["instancia"] =  message.obj
	elseif message_id == hash("objetivo_encontrado") then
		datos.nivel_completado = true
		finalizar_botones(self)
		msg.post("/ui_objetos#ui_objetos", "nivel_completado")
		msg.post("/delta#delta", "nivel_superado")
		msg.post("/nivel_superado#nivel_superado", "nivel_superado")
		msg.post("", "release_input_focus")
		gui.move_above(self.objetivo, self.laser)
		gui.play_flipbook(self.objetivo, "objetivo_on")
		local pos = gui.get_position(self.objetivo) -- por qué está esto acá? Ver después si hay tiempo.
		pos.x = pos.x +10
		gui.animate(self.objetivo, "scale",1.1, gui.EASING_INCIRC, 3, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
		print("Objetivo encontrado - nivel superado")
		niveles[self.nivel]["superado"] = true
	elseif message_id == hash("switch_activado") then
		self.cantidad_de_switches_activados = self.cantidad_de_switches_activados + 1
		--print("activando " .. self.cantidad_de_switches_activados)
		--pprint(message)
		--pprint(self.switches)
		for i = 1, table.maxn(self.switches) do
			if message.nodo == tostring(self.switches[i]) then
				--print("cambiar color nodo")
				gui.play_flipbook(self.switches[i], "switch_on")
			end	
		end
		if self.cantidad_de_switches_activados == self.cantidad_de_switches_en_el_nivel then
			print("cantidad de switches necesaria activada")
			desactivar_activar_barrera(self)
		end
		
	elseif message_id == hash("switch_desactivado") then
		for i = 1, table.maxn(self.switches) do
			if message.nodo == tostring(self.switches[i]) then
			--	print("cambiar color nodo")
			gui.play_flipbook(self.switches[i], "switch_off")
			end	
		end
		self.cantidad_de_switches_activados = self.cantidad_de_switches_activados - 1
		desactivar_activar_barrera(self)
		msg.post("/objetivo#objetivo", "desactivar_objetivo")
		--print("desactivando " .. self.cantidad_de_switches_activados)
		
	elseif message_id == hash("laser_en_barrera") then
		self.laser_en_barrera = true -- chquea si llego el laser a la barrera antes de activar todos los switches
	elseif message_id == hash("mover_adorno") then
		gui.set_enabled(self.adorno, true)
		gui.set_position(self.adorno, message.pos)
		if self.ultimo_pressed == true then
			sound.play("/sonidos#adorno_1", {gain = datos.gain_sfx})
		end
	elseif message_id == hash("sacar_adorno") then
		gui.set_enabled(self.adorno, false)
	elseif message_id == hash("finalizar_gui_gameplay") then
		self.volver_a_seleccion_de_nivel = true
		terminar_escena_gameplay(self)
	elseif message_id == hash("avanzar_de_nivel") then
		print("avanzar_de_nivel")
		terminar_escena_gameplay(self)
	elseif message_id == hash("tomar_input") then
		msg.post("", "acquire_input_focus")
	end
end


function on_input(self, action_id, action)

	if action_id == hash("touch") and action.pressed then
		for _,casillero in pairs(self.espejos) do -- Repasa la tabla de self.espejos
			if gui.pick_node(casillero[("espejo")], action.x, action.y) then
				self.ui_objetos = true
				self.ultimo_obj_clickeado = casillero[("espejo")]
				-- esta parta kv es para girar las instancias fisicas
				for k, v in pairs(self.casillas) do
					if tostring(v[1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
						--print("iguales")
						--print(k, v)
						self.ultima_casilla = k
					end	
				end
				
				local pos_obj = gui.get_position(self.ultimo_obj_clickeado)
				local obj = self.ultimo_obj_clickeado
				mover_abajo_botones(self, obj)
				-- Ahora el menu abre cuando el click es released
				--print("enviando mensaje al ui")
				--msg.post("/ui_objetos#ui_objetos", "activar_ui_objetos", {pos = pos_obj, obj = tostring(obj)})
				self.delta_pos = pos_obj
				self.moviendo_obj = true
				datos.obj_en_mouse = self.ultimo_obj_clickeado
				sound.play("/sonidos#adorno_1", {gain = datos.gain_sfx * 1.25})
				datos.animar_click(self, self.ultimo_obj_clickeado, 1.35)
				print("esto?")
				for k, v in pairs(self.casillas) do
					-- desocupa la casilla y borra obj físico
					if tostring(self.casillas[k][1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
						self.casillas[k]["ocupado"] = false
						--print("guardando casilla delta")
						self.casilla_delta = k
					end
				end
			end
		end
		self.ultimo_pressed = true
	end

	
	if action_id == hash("touch") then -- crea objetos y los reja en una casilla o elimina, drag and drop.
		
		if action.pressed then
			self.ultimo_pressed = true
			if gui.pick_node(self.espejo, action.x, action.y) or gui.pick_node(self.toolbar, action.x, action.y) then
				--crear espejo para poner
					sound.play("/sonidos#click_sobre_espejo", {gain = datos.gain_sfx})
					self.ultimo_obj_clickeado = nil
					self.ultimo_nodo_creado = clonar_nodo(self, self.espejo, hash("espejo"), vmath.vector3(action.x, action.y, 0), self.espejos, true)


					mover_bajo_adorno(self, self.ultimo_nodo_creado)
					mover_abajo_botones(self, ultimo_nodo_creado) -- ?

					self.ultimo_obj_clickeado = self.ultimo_nodo_creado
					self.moviendo_obj = false
					datos.animar_click(self, self.toolbar)
				
			elseif gui.pick_node(self.espejo_doble, action.x, action.y) then
					self.ultimo_obj_clickeado = nil
					self.ultimo_nodo_creado = clonar_nodo(self, self.espejo, hash("espejo"), vmath.vector3(action.x, action.y, 0), self.espejos, true)
					gui.play_flipbook(self.ultimo_nodo_creado, "espejo_doble")
					self.ultimo_obj_clickeado = self.ultimo_nodo_creado
					self.moviendo_obj = false
			elseif gui.pick_node(self.play_stop, action.x, action.y) and gui.is_enabled(self.play_stop )then -- Enciende y apaga el laser.
				if self.ui_objetos == false then -- play stop
					gui.play_flipbook(self.play_stop, "boton_stop")
					msg.post("/laser#laser", "disparar_ray_cast")
					self.cantidad_de_switches_activados = 0
					self.laser_en_barrera = false
					gui.set_enabled(self.barrera, true)
					msg.post("/barrera#barrera", "activar_barrera")
					for i = 1, table.maxn(datos.switches) do
						gui.animate(datos.switches[i], "color", vmath.vector4(0.8,0.17,0.17,1), gui.EASING_INBACK, 0.15)
					end
				end
			elseif gui.pick_node(self.retroceder, action.x, action.y) then
				sound.play("/sonidos#sonido_volver", {gain = datos.gain_sfx})
				datos.animar_click(self, self.retroceder, 0.7, 0.6)
				
				msg.post("", "release_input_focus")
				self.volver_a_seleccion_de_nivel = true
				terminar_escena_gameplay(self)
				
			elseif gui.pick_node(self.sonido_nodo, action.x, action.y) then
				datos.animar_click(self, self.sonido_nodo, 0.7, 0.6)
				datos.sonido_on_off()
				if datos.sonido == true then
					gui.play_flipbook(self.sonido_nodo, "sonido on")
				else
					gui.play_flipbook(self.sonido_nodo, "sonido off")
				end
			elseif gui.pick_node(self.lupa, action.x, action.y) then
				datos.animar_click(self, self.lupa)
				if self.pistas_activadas == false then
					self.pistas_activadas = true
					sound.play("/sonidos#lupa", {gain = datos.gain_sfx})
					gui.animate(self.lupa, "position.x", 1391, gui.EASING_INBACK, 1, 0,
					function()
						gui.set_enabled(self.lupa, false)
					end)
					
					for p = 1,table.maxn(self.pistas) do
						gui.animate(self.pistas[p][hash("pista")], "color", vmath.vector4(1,1,1,1), gui.EASING_LINEAR, 2, 0,
						function()
							gui.animate(self.pistas[p][hash("pista")], "color", vmath.vector4(1,1,1,0.25), gui.EASING_LINEAR, 2, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
						end)
					end
				end
			end
		elseif action.released then
			self.ultimo_pressed = false
			
			if self.mouse_sobre_casillas == false and datos.obj_en_mouse ~= nil and self.moviendo_obj == false then
				-- Suelta y elimina el objeto si se soltó por fuera de una casilla y libera "obj_en_mouse".
				-- Acá se puede chequear si que pasa si se suelta sobre otro nodo o casilla ya ocupada.
					for i = table.maxn(self.espejos), 1, -1 do
						if datos.obj_en_mouse == self.espejos[i][hash("espejo")] then
							gui.delete_node(self.espejos[i][hash("espejo")])
							table.remove(self.espejos, i)
							print("borrando nodo 1")
							--datos.obj_en_mouse = nil
							if self.moviendo_obj == true then
								msg.post(self.casillas[self.casilla_delta]["instancia"], "borrar_obj")
								self.casillas[self.casilla_delta]["instancia"] = nil -- esta pos de table es la instancia del objeto físico.
							end
						end
					end
					datos.obj_en_mouse = nil
					self.moviendo_obj = false
					
			elseif self.casillas[self.ultima_casilla]["ocupado"] == true and datos.obj_en_mouse ~= nil then
				-- Suelta el objeto dejándolo en una casilla, la función de abajo se encarga de esto. Libera "obj_en_mouse".
					print("No podés dejar el obj en la casillero (" .. self.ultima_casilla .. ") " .. tostring(self.casillas[self.ultima_casilla ]["ocupado"]))
					for i = table.maxn(self.espejos), 1, -1 do
						--pprint(self.espejos[i])
						if self.ultimo_obj_clickeado == self.espejos[i][hash("espejo")] and self.moviendo_obj == false then	
							gui.delete_node(self.espejos[i][hash("espejo")])
							table.remove(self.espejos, i)
							mover_relevo(self, vmath.vector3())
							print("borrando nodo 2") -- Borra el objeto dejado en una posicion inválida mientras no tenga un objeto físico con sí mismo.
						elseif self.ultimo_obj_clickeado == self.espejos[i][hash("espejo")] and self.moviendo_obj == true then
							for k, v in pairs(self.espejos) do --?? no es necesario el loop creo
								gui.set_position(self.ultimo_obj_clickeado, self.delta_pos)
							end
							for k, v in pairs(self.casillas) do
								-- ocupa la casilla y borra obj físico
								if tostring(self.casillas[k][1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
									self.casillas[k]["ocupado"] = true
								end
							end
							for k, v in pairs(self.casillas) do
								if tostring(v[1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
									self.ultima_casilla = k
									--pprint(v)
								end
							end
							if self.mouse_sobre_casillas == false then
								msg.post("/gui#gui", "accion_ui_obj", {accion = "borrar_objeto"})
								msg.post("/ui_objetos#ui_objetos", "desactivar_ui_objetos")
								mover_tacho(self, self.tacho_pos_inical, nil)
								
							else
								print(self.mouse_sobre_casillas)
								print("restablecer pos") -- Restablece la pos del objeto físico si está dentro de las casillas.
								--pprint(gui.get_position(self.casillas[self.casilla_delta][1][hash("casilla")]))
								local pos_de_restablecimiento = gui.get_position(self.casillas[self.casilla_delta][1][hash("casilla")])
								msg.post(self.casillas[self.casilla_delta]["instancia"], "mover_obj", {pos = pos_de_restablecimiento})
								gui.set_position(self.casillas[self.casilla_delta]["laser"], pos_de_restablecimiento)
								--mensaje_para_ui (self)
							end

						end
					end	
					datos.obj_en_mouse = nil
					self.moviendo_obj = false
					
				elseif self.casillas[self.ultima_casilla]["ocupado"] == false and datos.obj_en_mouse ~= nil then
					datos.obj_en_mouse = nil
					self.casillas[self.ultima_casilla]["ocupado"] = true
					if self.casilla_delta == self.ultima_casilla and self.moviendo_obj == true then
						--print("abrir menu") -- por el momento esto funciona
						-- abre el menú cuando debe, la acción del click parece funcionar, y en teoría saca el input focus,
						-- hay que probar.
						mensaje_para_ui (self)
						
						--datos.animar_click(self, self.ultimo_obj_clickeado, 1.35)
						--print("aca?")
						msg.post("", "release_input_focus") 
					end
					-- crear physics obj
					if self.moviendo_obj == true then
					--print(self.ultima_casilla)
						if self.casilla_delta ~= self.ultima_casilla and self.mouse_sobre_casillas == true then
						
							--print(self.casillas[self.casilla_delta]["instancia"])
							
							self.casillas[self.ultima_casilla]["instancia"] = self.casillas[self.casilla_delta]["instancia"]
							msg.post(self.casillas[self.ultima_casilla]["instancia"], "mover_obj", {pos = self.pos_casilla})
							self.casillas[self.ultima_casilla]["laser"] = self.casillas[self.casilla_delta]["laser"]
							
							--print(self.casillas[self.ultima_casilla]["laser"])
							gui.set_position(self.casillas[self.ultima_casilla]["laser"], self.pos_casilla)
							self.casillas[self.casilla_delta]["instancia"] = nil 
							sound.play("/sonidos#adorno_2", {gain = datos.gain_sfx * 1.25})
							--print("mover obj fisico // gui")
						elseif self.mouse_sobre_casillas == false then
							-- Esto está así porque antes los objetos no se borraban desde afuera. Esperemos que funcione. Si hay tiempo ver de escribirlo de una forma mas robusta.
							print("Restableciendo obj desde afuera y borrando.") -- Restablece la pos del objeto físico si está fuera de las casillas y luego los borra
							local pos_de_restablecimiento = gui.get_position(self.casillas[self.casilla_delta][1][hash("casilla")])
							msg.post(self.casillas[self.casilla_delta]["instancia"], "mover_obj", {pos = pos_de_restablecimiento})
							gui.set_position(self.casillas[self.casilla_delta]["laser"], pos_de_restablecimiento)
							
							gui.set_position(self.ultimo_obj_clickeado, self.delta_pos)
							self.casillas[self.ultima_casilla]["ocupado"] = false
							self.casillas[self.casilla_delta]["ocupado"] = true

							msg.post("/gui#gui", "accion_ui_obj", {accion = "borrar_objeto"})
							msg.post("/ui_objetos#ui_objetos", "desactivar_ui_objetos")
							mover_tacho(self, self.tacho_pos_inical, nil)
							
							return
						end
						--mensaje_para_ui (self)
						return
					elseif gui.get_flipbook(self.ultimo_nodo_creado) == hash("espejo") and self.moviendo_obj == false then
						msg.post("/espejos#espejosfactory", "crear_physics_obj",{x = self.pos_casilla.x , y = self.pos_casilla.y})
						local nuevo_laser_beam = clonar_nodo(self, self.laser_beam, hash("laser_beam"), self.pos_casilla, {}, false)
						self.casillas[self.ultima_casilla]["laser"] = nuevo_laser_beam
						gui.set_scale(nuevo_laser_beam, vmath.vector3(1,1,0))
						gui.move_below(nuevo_laser_beam, self.ultimo_nodo_creado)
						--print(self.ultimo_nodo_creado)
						for i = 1, table.maxn(self.espejos) do -- Pone los laser en la tabla de espejos para mejor control.
							if self.ultimo_nodo_creado == self.espejos[i][hash("espejo")] then
								self.espejos[i]["laser"] = nuevo_laser_beam
							--	pprint(self.espejos)
							--	print("MISMO NODO")
							end
						end
						--print("creando laser beam")
					elseif gui.get_flipbook(self.ultimo_nodo_creado) == hash("espejo_doble") and self.moviendo_obj == false then
						msg.post("/espejos_dobles#espejosdoblesfactory", "crear_physics_obj",{x = self.pos_casilla.x , y = self.pos_casilla.y})
					end
					self.moviendo_obj = false
					mover_relevo(self, vmath.vector3())
					--mensaje_para_ui (self)
					sound.play("/sonidos#adorno_2", {gain = datos.gain_sfx * 1.25})
					print("Colocando obj en casillero número (" .. self.ultima_casilla .. ") " .. tostring(self.casillas[self.ultima_casilla ]["ocupado"]))
				end
				gui.set_enabled(self.cruz, false)
				msg.post("/obj_fisico_relevo", "mover_obj_fisico_relevo", {pos = vmath.vector3(0, -500, 0)})
				datos.obj_en_mouse = nil
			end
			
	end
	
	if action_id == nil then
		datos.pos_del_mouse.x = action.x -- Guarda la pos del mouse en movimiento.
		datos.pos_del_mouse.y = action.y
		
		for _,casillero in pairs(self.casillas) do -- Repasa la tabla de self.casillas
			
			if gui.pick_node(casillero[1][("casilla")], action.x, action.y) then
				self.mouse_sobre_casillas = true
				
				mover_tacho(self, self.tacho_pos_inical, nil)
				if datos.obj_en_mouse ~= nil then
					-- Si el mouse tiene un objeto y está sobre una casilla guarda la posición de esa casilla.
					-- Además pone al obj_en_mouse en esa posición.
					-- Así cuando el touch es released y se está sobre una casilla el objeto queda en esa posición.
					
					self.pos_casilla = gui.get_position(casillero[1][("casilla")])
					
					gui.set_position(datos.obj_en_mouse, self.pos_casilla)
					
					self.ultima_casilla = _
					--print(self.ultima_casilla)
					if self.casillas[self.ultima_casilla]["ocupado"] == true then
						--print("esta casilla está ocupada")

						if casillero[self.ultima_casilla] ~= nil then
							-- Esto no termino de entender porque hace erroe si no hago este chequeo pero parece arreglar el problema.
							-- ASI VACIO PARECE FUNCIONAR, RARO.
							--print(casillero[self.ultima_casilla][1])
							--gui.move_above(self.cruz, casillero[self.ultima_casilla][1])
						else
							--print("alguito")
							gui.move_above(self.cruz, casillero[self.ultima_casilla])
						end


						gui.set_enabled(self.cruz, true)
						msg.post("/obj_fisico_relevo", "mover_obj_fisico_relevo", {pos = self.pos_casilla})
						gui.set_position(self.cruz, self.pos_casilla)
						
						
					else

					end
					if self.moviendo_obj == true then
						-- Hace que el obj físico siga el espejo mientras se está moviendo dentro de las casillas
						--print(self.pos_casilla)
						msg.post(self.casillas[self.casilla_delta]["instancia"], "mover_obj", {pos = self.pos_casilla})
						gui.set_position(self.casillas[self.casilla_delta]["laser"], self.pos_casilla)
						--mensaje_para_ui (self)
					elseif self.moviendo_obj == false then
						mover_relevo(self, self.pos_casilla)

					end
					
				end
				
				return -- Tope para que el mouse sobre cailla y el código de arriba funcione.
			end
			self.mouse_sobre_casillas = false -- resetea el mouse sobre casillas para que no se cuelgue.
			gui.set_enabled(self.cruz, false)
			msg.post("/obj_fisico_relevo#obj_fisico_relevo", "mover_obj_fisico_relevo", {pos = vmath.vector3(0, -500, 0)})
		end
		if datos.obj_en_mouse ~= nil then
			-- Esto hace que el objeto en mouse siga al mouse cuando no está sobre una casilla.
			gui.set_position(datos.obj_en_mouse, datos.pos_del_mouse)
			if self.moviendo_obj == true then
				-- Hace que el obj físico siga el espejo mientras se está moviendo fuera de las casillas
				msg.post(self.casillas[self.casilla_delta]["instancia"], "mover_obj", {pos = datos.pos_del_mouse})
				gui.set_position(self.casillas[self.casilla_delta]["laser"], datos.pos_del_mouse)
				mover_tacho(self, datos.pos_del_mouse, datos.obj_en_mouse)

				
			elseif self.moviendo_obj == false then
				mover_relevo(self, vmath.vector3())
				mover_tacho(self, self.tacho_pos_inical, nil)
			end
		end
	end
	

	if action_id == hash("fisicas") and action.pressed then
		if datos.dibujar_linea == false then
			datos.dibujar_linea = true
		else
			datos.dibujar_linea = false
		end
		msg.post("@system:", "toggle_physics_debug")
	end
end
