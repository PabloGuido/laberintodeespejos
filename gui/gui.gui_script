local datos = require("main.datos")
local dif_entre_casillas = 96
local function clonar_nodo(self, que_nodo, que_hash, pos, que_tabla, en_mouse)
	local nuevo_nodo = gui.clone_tree(que_nodo)
	local clon_nodo = nuevo_nodo[que_hash]
	gui.set_position(clon_nodo, pos)
	table.insert(que_tabla, nuevo_nodo)
	local obj_en_mouse = en_mouse
	if obj_en_mouse == true then
		datos.obj_en_mouse = clon_nodo
	end
	return clon_nodo
end

-- laser beam -------------------
local function dist2d(x1, y1, x2, y2)
	return ((x2-x1)^2+(y2-y1)^2)^0.5
end

local function angle_of_vector_between_two_points(x1,y1, x2,y2) 
	return math.atan2(y2-y1, x2-x1) 
end

---------------------------------

function init(self)
	self.ultima_casilla = 1
	self.pos_casilla = vmath.vector3()
	self.mouse_sobre_casillas = false -- Registra si el mouse está sobre un casillero.
	self.ultimo_obj_clickeado = nil
	-- nodos -----------------------------------------
	self.casilla = gui.get_node("casilla") -- casilla vacía
	self.cruz = gui.get_node("cruz")
	gui.set_enabled(self.cruz, false)
	-- laser beam -----------------------------------------
	self.laser_beam = gui.get_node("laser_beam")
	gui.is_enabled(self.laser_beam, false)
	self.position = gui.get_position(self.laser_beam )
	self.target_position = gui.get_position(self.laser_beam )
	self.scale = gui.get_scale(self.laser_beam )
	-- clonacion de beams
	self.laser_tabla = {}
	
	
	-- obj toolbar
	self.espejo = gui.get_node("espejo")
	self.ui_objetos = false

	-- tablas -----------------------------------------
	self.casillas = {}
	self.casillas["obj_fisico"] = nil
	self.espejos = {}
	---------------------------------------------------
	
	self.obj_seleccionado = ""

	msg.post("", "acquire_input_focus")

	---------------------------------------------------
	self.pos = vmath.vector3(440,600,0) -- posicion inicial para crear la grilla
	for i = 1, 5 do	
		for i = 1, 5 do	
			local nueva_casilla = gui.clone_tree(self.casilla)
			local clon_casilla = nueva_casilla[hash("casilla")]	
			gui.set_position(clon_casilla, self.pos)
			self.pos.x = self.pos.x + dif_entre_casillas
			table.insert(self.casillas, {nueva_casilla, ocupado = false})
		end
		self.pos.x = 440
		self.pos.y = self.pos.y - dif_entre_casillas
	end
	gui.set_enabled(self.casilla, false) -- ver que esto no haga bardo dsp
	---------------------------------------------------
end

--function update(self, dt)

--end

function on_message(self, message_id, message, sender)
	--pprint(message_id)
	if message_id == hash("obj_seleccionado") then
		self.obj_seleccionado = message.objeto
		--(self.obj_seleccionado .. " <from> guiscript")
	elseif message_id == hash("dibujar_laser") then
		--print("dibujar laser")
		local sender_pos = message.pos_inicial_laser
		local nuevo_laser_beam = clonar_nodo(self, self.laser_beam, hash("laser_beam"), sender_pos, self.laser_tabla, false)
		--pprint(message)
		if message.datos then
			--pprint(message)
			msg.post("", "release_input_focus")
			local distance = dist2d(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
			self.scale.x = distance

				gui.animate(nuevo_laser_beam, "scale.x", self.scale, gui.EASING_LINEAR, 0.25, 0,
				function()
					msg.post("", "acquire_input_focus")
					msg.post(message.datos.id, "disparar_ray")
				end)

			local direction = angle_of_vector_between_two_points(message.pos_inicial_laser.x, message.pos_inicial_laser.y, message.datos.position.x, message.datos.position.y)
			local rotation = vmath.quat_rotation_z(direction)
			gui.set_rotation(nuevo_laser_beam, rotation)
		else
			msg.post("", "release_input_focus")
			local distance = dist2d(message.pos_inicial_laser.x, message.pos_inicial_laser.y, 1000, self.position.y)
			self.scale.x = distance
			gui.animate(nuevo_laser_beam, "scale.x", self.scale, gui.EASING_LINEAR, 0.25, 0,
			function()
				msg.post("", "acquire_input_focus")
			end)
			local direction = angle_of_vector_between_two_points(message.pos_inicial_laser.x, message.pos_inicial_laser.y, 1000, message.pos_inicial_laser.y)
			local rotation = vmath.quat_rotation_z(direction)
			gui.set_rotation(nuevo_laser_beam, rotation)
		end
	elseif message_id == hash("borrar_laser") then
		for i = table.maxn(self.laser_tabla), 1, -1 do
			-- elimina los laser
			gui.delete_node(self.laser_tabla[i][hash("laser_beam")])
			table.remove(self.laser_tabla, i)
		end
	elseif message_id == hash("accion_ui_obj") then
		--pprint(self.casillas)
		--print(self.ultimo_obj_clickeado)
		--[[ esto de no pasar nada raro hay que borrar ++++++++++++++++++++++++
		for k, v in pairs(self.casillas) do
			if tostring(v[1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
				--print("iguales")
				--print(k, v)
				self.ultima_casilla = k
			end
			--print(v[1][hash("casilla")])
		end
		print(self.ultima_casilla)
		]]
		msg.post("", "release_input_focus")
		if message.accion == "derecha" then
			local rot = gui.get_rotation(self.ultimo_obj_clickeado)
			gui.animate(self.ultimo_obj_clickeado, "rotation.z", rot.z - 90, gui.EASING_INBACK, 0.5, 0,
			function()
				--print(self.casillas[self.ultima_casilla][10])
				msg.post(self.casillas[self.ultima_casilla][10], "accion_gui", {accion= "rot_der", valor = -1})
				msg.post("/ui_objetos#ui_objetos", "restablecer_input")
				msg.post("", "acquire_input_focus")
			end	)
		elseif message.accion == "izquierda" then
			local rot = gui.get_rotation(self.ultimo_obj_clickeado)
			gui.animate(self.ultimo_obj_clickeado, "rotation.z", rot.z + 90, gui.EASING_INBACK, 0.5, 0,
			function()
				msg.post(self.casillas[self.ultima_casilla][10], "accion_gui", {accion= "rot_izq", valor = 1})
				msg.post("/ui_objetos#ui_objetos", "restablecer_input")
				msg.post("", "acquire_input_focus")
			end	)
		elseif message.accion == "aceptar" then
			self.ui_objetos = false
			msg.post("", "acquire_input_focus")
		elseif message.accion == "borrar_objeto" then
			for i = table.maxn(self.espejos), 1, -1 do
				if self.ultimo_obj_clickeado == self.espejos[i][hash("espejo")] then
					-- borra nodo espejo
					gui.delete_node(self.espejos[i][hash("espejo")])
					table.remove(self.espejos, i)

					for k, v in pairs(self.casillas) do
						-- desocupa la casilla y borra obj físico
						if tostring(self.casillas[k][1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
							self.casillas[k]["ocupado"] = false
							msg.post(self.casillas[self.ultima_casilla][10], "borrar_obj")
							self.casillas[self.ultima_casilla][10] = nil -- esta pos de table es la instancia del objeto físico.
							
						end
					end
				end
			end
			self.ui_objetos = false
			msg.post("", "acquire_input_focus")
		end
			
	elseif message_id == hash("guardar_obj_fisico") then
		--print(message)
		--print(self.ultimo_obj_clickeado)
		-- cambiar casillas por espejos
		--pprint(self.espejos)
		table.insert(self.casillas[self.ultima_casilla], 10, message.obj)
	end

end

function on_input(self, action_id, action)
	 --esto hay que cambuiar dsp a rotar objs
	if action_id == hash("touch") and action.pressed then
		for _,casillero in pairs(self.espejos) do -- Repasa la tabla de self.espejos
			if gui.pick_node(casillero[("espejo")], action.x, action.y) then
				self.ui_objetos = true
				-- arreglar que instancia fisica rota
				--msg.post("", "release_input_focus")
				--pprint(self.espejos)
				self.ultimo_obj_clickeado = casillero[("espejo")]
				-- esta parta kv es para girar las instancias fisicas
				for k, v in pairs(self.casillas) do
					if tostring(v[1][hash("casilla")]) == tostring(self.ultimo_obj_clickeado) then
						--print("iguales")
						--print(k, v)
						self.ultima_casilla = k
					end
					--print(v[1][hash("casilla")])
				end
				--print(self.ultima_casilla)
				
				local pos_obj = gui.get_position(self.ultimo_obj_clickeado)
				local obj = self.ultimo_obj_clickeado
				--print("enviando mensaje al ui")
				msg.post("/ui_objetos#ui_objetos", "activar_ui_objetos", {pos = pos_obj, obj = tostring(obj)})
			end
		end
	end	

	
	if action_id == hash("touch") then -- crea objetos y los reja en una casilla o elimina, drag and drop.
		
		if action.pressed then
			if gui.pick_node(self.espejo, action.x, action.y) then
				--crear espejo para poner
				if self.ui_objetos == false then
			self.ultimo_obj_clickeado = nil
			self.ultimo_nodo_creado = clonar_nodo(self, self.espejo, hash("espejo"), vmath.vector3(action.x, action.y, 0), self.espejos, true)
				end
			end			
		elseif action.released then
			if self.mouse_sobre_casillas == false and datos.obj_en_mouse ~= nil then
				-- Suelta y elimina el objeto si se soltó por fuera de una casilla y libera "obj_en_mouse".
				-- Acá se puede chequear si que pasa si se suelta sobre otro nodo o casilla ya ocupada.
					
					for i = table.maxn(self.espejos), 1, -1 do
						if datos.obj_en_mouse == self.espejos[i][hash("espejo")] then
							gui.delete_node(self.espejos[i][hash("espejo")])
							table.remove(self.espejos, i)
							print("borrando nodo")
						end
					end
					datos.obj_en_mouse = nil
					
			elseif self.casillas[self.ultima_casilla]["ocupado"] == true and datos.obj_en_mouse ~= nil then
				-- Suelta el objeto dejándolo en una casilla, la función de abajo se encarga de esto. Libera "obj_en_mouse".
					print("No podés dejar el obj en la casillero (" .. self.ultima_casilla .. ") " .. tostring(self.casillas[self.ultima_casilla ]["ocupado"]))
					for i = table.maxn(self.espejos), 1, -1 do
						if datos.obj_en_mouse == self.espejos[i][hash("espejo")] then
							gui.delete_node(self.espejos[i][hash("espejo")])
							table.remove(self.espejos, i)
							print("borrando nodo")
						end
					end
					datos.obj_en_mouse = nil
					
				elseif self.casillas[self.ultima_casilla]["ocupado"] == false and datos.obj_en_mouse ~= nil then
					datos.obj_en_mouse = nil
					self.casillas[self.ultima_casilla]["ocupado"] = true
					-- crear physics obj
					msg.post("/espejos#espejosfactory", "crear_physics_obj",{x = self.pos_casilla.x , y = self.pos_casilla.y})
					print("Colocando obj en casillero número (" .. self.ultima_casilla .. ") " .. tostring(self.casillas[self.ultima_casilla ]["ocupado"]))
				end
			gui.set_enabled(self.cruz, false)
		end
	end
	
	if action_id == nil then
		datos.pos_del_mouse.x = action.x -- Guarda la pos del mouse en movimiento.
		datos.pos_del_mouse.y = action.y
		
		for _,casillero in pairs(self.casillas) do -- Repasa la tabla de self.casillas
			
			if gui.pick_node(casillero[1][("casilla")], action.x, action.y) then
				self.mouse_sobre_casillas = true
				if datos.obj_en_mouse ~= nil then
					-- Si el mouse tiene un objeto y está sobre una casilla guarda la posición de esa casilla.
					-- Además pone al obj_en_mouse en esa posición.
					-- Así cuando el touch es released y se está sobre una casilla el objeto queda en esa posición.

					self.pos_casilla = gui.get_position(casillero[1][("casilla")])
					gui.set_position(datos.obj_en_mouse, self.pos_casilla)
					self.ultima_casilla = _
					if self.casillas[self.ultima_casilla]["ocupado"] == true then
						--print("esta casilla está ocupada")
						if casillero[self.ultima_casilla] ~= nil then
							-- Esto no termino de entender porque hace erroe si no hago este chequeo pero parece arreglar el problema.
							gui.move_above(self.cruz, casillero[self.ultima_casilla][1])
						else
							gui.move_above(self.cruz, casillero[self.ultima_casilla])
						end
						gui.set_enabled(self.cruz, true)
						gui.set_position(self.cruz, self.pos_casilla)
						
						
					else
						gui.set_enabled(self.cruz, false)
					end

					--pprint(casillero[1]["casilla"] )--.. casillero["ocupado"])
					--print(self.ultima_casilla)

					
				end
				return -- Tope para que el mouse sobre cailla y el código de arriba funcione.
			end
			self.mouse_sobre_casillas = false -- resetea el mouse sobre casillas para que no se cuelgue.
			gui.set_enabled(self.cruz, false)
		end
		if datos.obj_en_mouse ~= nil then
			-- Esto hace que el objeto en mouse siga al mouse cuando no está sobre una casilla.
			gui.set_position(datos.obj_en_mouse, datos.pos_del_mouse)
		end
	end
	
	if action_id == hash("ray") and action.pressed then
		if self.ui_objetos == false then
			msg.post("/laser#laser", "disparar_ray_cast")
		end
	elseif action_id == hash("fisicas") and action.pressed then
		if datos.dibujar_linea == false then
			datos.dibujar_linea = true
		else
			datos.dibujar_linea = false
		end
		msg.post("@system:", "toggle_physics_debug")
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
